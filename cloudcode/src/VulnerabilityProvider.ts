// src/VulnerabilityProvider.ts

import * as vscode from 'vscode';
import * as path from 'path';

// Define the structure of a vulnerability object (no changes here)
interface Vulnerability {
    file_path: string;
    line_number: number;
    vulnerability_type: string;
    description: string;
    suggested_solution: string;
}

// THIS TYPE ALIAS WAS THE SOURCE OF THE ERROR AND HAS BEEN REMOVED
// type TreeItem = FileItem | VulnerabilityItem | DetailItem;

export class VulnerabilityProvider implements vscode.TreeDataProvider<vscode.TreeItem> {
    // The generic for the EventEmitter is now vscode.TreeItem
    private _onDidChangeTreeData: vscode.EventEmitter<vscode.TreeItem | undefined | null | void> = new vscode.EventEmitter<vscode.TreeItem | undefined | null | void>();
    readonly onDidChangeTreeData: vscode.Event<vscode.TreeItem | undefined | null | void> = this._onDidChangeTreeData.event;

    private vulnerabilities: Vulnerability[] = [];
    private workspaceRoot: string = '';
    private scanCompleted: boolean = false;

    // The type for the 'element' parameter is now the base vscode.TreeItem
    getTreeItem(element: vscode.TreeItem): vscode.TreeItem {
        return element;
    }

    // The parameter and return types now correctly use the base vscode.TreeItem
    getChildren(element?: vscode.TreeItem): vscode.ProviderResult<vscode.TreeItem[]> {
        if (!this.workspaceRoot) {
            return [new vscode.TreeItem("Run 'Scan for Vulnerabilities' to see results.", vscode.TreeItemCollapsibleState.None)];
        }

        if (element) {
            // We use 'instanceof' to check which specific custom class we're dealing with
            if (element instanceof FileItem) {
                return element.vulnerabilities.map(vuln => new VulnerabilityItem(vuln, this.workspaceRoot));
            }
            if (element instanceof VulnerabilityItem) {
                return [
                    new VulnerabilityDetailItem("Description", element.vulnerability.description),
                    new VulnerabilityDetailItem("Suggested Solution", element.vulnerability.suggested_solution),
                ];
            }
        } else {
            // Root level
            if (this.vulnerabilities.length === 0 && this.scanCompleted) {
                 return [new vscode.TreeItem("Scan complete. No vulnerabilities found.", vscode.TreeItemCollapsibleState.None)];
            }
            
            const groupedByFile = this.vulnerabilities.reduce((acc, vuln) => {
                (acc[vuln.file_path] = acc[vuln.file_path] || []).push(vuln);
                return acc;
            }, {} as { [key: string]: Vulnerability[] });

            return Object.keys(groupedByFile).map(filePath => new FileItem(filePath, groupedByFile[filePath]));
        }
    }

    public clear(): void {
        this.vulnerabilities = [];
        this.workspaceRoot = '';
        this.scanCompleted = false;
        this._onDidChangeTreeData.fire();
    }

    public addVulnerabilities(newData: Vulnerability[], workspaceRoot: string): void {
        if (!this.workspaceRoot) {
            this.workspaceRoot = workspaceRoot;
        }
        this.vulnerabilities.push(...newData);
        this._onDidChangeTreeData.fire();
    }

    public setScanComplete(): void {
        this.scanCompleted = true;
        if (this.vulnerabilities.length === 0) {
            this._onDidChangeTreeData.fire();
        }
    }
}

// --- Custom TreeItem Classes ---
// All these classes extend vscode.TreeItem, so they are compatible with the provider.

class FileItem extends vscode.TreeItem {
    constructor(
        public readonly filePath: string,
        public readonly vulnerabilities: Vulnerability[]
    ) {
        super(path.basename(filePath), vscode.TreeItemCollapsibleState.Expanded);
        this.description = path.dirname(filePath);
        this.tooltip = `${filePath} - ${vulnerabilities.length} issues found`;
        this.iconPath = new vscode.ThemeIcon('file-code');
    }
}

class VulnerabilityItem extends vscode.TreeItem {
    constructor(
        public readonly vulnerability: Vulnerability,
        private readonly workspaceRoot: string
    ) {
        super(vulnerability.vulnerability_type, vscode.TreeItemCollapsibleState.Expanded); // Expanded by default
        this.description = `Line ${vulnerability.line_number}`;
        this.tooltip = `Click to navigate to the line`;
        this.iconPath = new vscode.ThemeIcon('warning', new vscode.ThemeColor('editorWarning.foreground'));
        
        const absolutePath = path.join(this.workspaceRoot, this.vulnerability.file_path);
        const fileUri = vscode.Uri.file(absolutePath);
        
        this.command = {
            command: 'vscode.open',
            title: 'Open File',
            arguments: [ fileUri, { 
                selection: new vscode.Range(
                    new vscode.Position(this.vulnerability.line_number - 1, 0),
                    new vscode.Position(this.vulnerability.line_number - 1, 999)
                ),
                preview: true,
            }]
        };
    }
}

// Renamed from 'DetailItem' to be more specific
class VulnerabilityDetailItem extends vscode.TreeItem {
    constructor(
        public readonly label: string,
        public readonly fullContent: string
    ) {
        super(label, vscode.TreeItemCollapsibleState.None);
        this.description = this.fullContent.split('\n')[0];
        this.tooltip = new vscode.MarkdownString(this.fullContent, true);
        this.tooltip.isTrusted = true;
        this.iconPath = label === 'Description' ? new vscode.ThemeIcon('book') : new vscode.ThemeIcon('lightbulb');
    }
}
// src/VulnerabilityProvider.ts

import * as vscode from 'vscode';
import * as path from 'path';

// Updated interface to include the new, richer data from the backend
interface Vulnerability {
    file_path: string;
    line_number: number;
    line_of_code: string;
    vulnerability_type: string;
    severity: 'Critical' | 'High' | 'Medium' | 'Low' | string;
    cwe: string;
    description: string;
    suggested_solution: string;
}

export class VulnerabilityProvider implements vscode.TreeDataProvider<vscode.TreeItem> {
    private _onDidChangeTreeData: vscode.EventEmitter<vscode.TreeItem | undefined | null | void> = new vscode.EventEmitter<vscode.TreeItem | undefined | null | void>();
    readonly onDidChangeTreeData: vscode.Event<vscode.TreeItem | undefined | null | void> = this._onDidChangeTreeData.event;

    private vulnerabilities: Vulnerability[] = [];
    private workspaceRoot: string = '';
    private scanCompleted: boolean = false;

    getTreeItem(element: vscode.TreeItem): vscode.TreeItem {
        return element;
    }

    getChildren(element?: vscode.TreeItem): vscode.ProviderResult<vscode.TreeItem[]> {
        if (!this.workspaceRoot) {
            return [new vscode.TreeItem("Run 'Scan for Vulnerabilities' to see results.", vscode.TreeItemCollapsibleState.None)];
        }

        if (element) {
            if (element instanceof FileItem) {
                const sortedVulns = element.vulnerabilities.sort((a, b) => {
                    const severityOrder: { [key: string]: number } = { 'Critical': 0, 'High': 1, 'Medium': 2, 'Low': 3 };
                    return (severityOrder[a.severity] ?? 4) - (severityOrder[b.severity] ?? 4);
                });
                return sortedVulns.map(vuln => new VulnerabilityItem(vuln, this.workspaceRoot));
            }
            if (element instanceof VulnerabilityItem) {
                const vuln = element.vulnerability;
                return [
                    new InfoItem('Code Snippet', vuln.line_of_code, 'code', `At line ${vuln.line_number}`),
                    new InfoItem('Description', vuln.description, 'book'),
                    new InfoItem('Suggested Solution', vuln.suggested_solution, 'lightbulb'),
                    new LinkItem('Learn More (CWE)', vuln.cwe)
                ];
            }
        } else {
            if (this.vulnerabilities.length === 0 && this.scanCompleted) {
                 return [new vscode.TreeItem("Scan complete. No vulnerabilities found.", vscode.TreeItemCollapsibleState.None)];
            }
            const groupedByFile = this.vulnerabilities.reduce((acc, vuln) => {
                (acc[vuln.file_path] = acc[vuln.file_path] || []).push(vuln);
                return acc;
            }, {} as { [key: string]: Vulnerability[] });

            return Object.keys(groupedByFile).map(filePath => new FileItem(filePath, groupedByFile[filePath]));
        }
    }

    public clear(): void {
        this.vulnerabilities = [];
        this.workspaceRoot = '';
        this.scanCompleted = false;
        this._onDidChangeTreeData.fire();
    }

    public addVulnerabilities(newData: Vulnerability[], workspaceRoot: string): void {
        if (!this.workspaceRoot) {
            this.workspaceRoot = workspaceRoot;
        }
        this.vulnerabilities.push(...newData);
        this._onDidChangeTreeData.fire();
    }

    public setScanComplete(): void {
        this.scanCompleted = true;
        if (this.vulnerabilities.length === 0) {
            this._onDidChangeTreeData.fire();
        }
    }
}

class FileItem extends vscode.TreeItem {
    constructor(
        public readonly filePath: string,
        public readonly vulnerabilities: Vulnerability[]
    ) {
        super(path.basename(filePath), vscode.TreeItemCollapsibleState.Expanded);
        const issueCount = vulnerabilities.length;
        this.description = `${path.dirname(filePath)} - ${issueCount} issue${issueCount > 1 ? 's' : ''}`;
        this.tooltip = `${filePath}\nFound ${issueCount} potential vulnerabilities.`;
        this.iconPath = new vscode.ThemeIcon('file-code');
    }
}

class VulnerabilityItem extends vscode.TreeItem {
    constructor(
        public readonly vulnerability: Vulnerability,
        private readonly workspaceRoot: string
    ) {
        super(`[${vulnerability.severity}] ${vulnerability.vulnerability_type}`, vscode.TreeItemCollapsibleState.Collapsed);
        this.description = `L${vulnerability.line_number}: ${vulnerability.line_of_code.trim()}`;
        this.iconPath = this.getIconForSeverity(vulnerability.severity);
        
        const absolutePath = path.join(this.workspaceRoot, this.vulnerability.file_path);
        const fileUri = vscode.Uri.file(absolutePath);
        
        this.command = {
            command: 'vscode.open', title: 'Open File',
            arguments: [ fileUri, { 
                selection: new vscode.Range(
                    new vscode.Position(vulnerability.line_number - 1, 0),
                    new vscode.Position(vulnerability.line_number - 1, 999)
                ),
                preview: true,
            }]
        };
    }

    private getIconForSeverity(severity: Vulnerability['severity']): vscode.ThemeIcon {
        switch (severity) {
            case 'Critical':
                return new vscode.ThemeIcon('error', new vscode.ThemeColor('errorForeground'));
            case 'High':
                return new vscode.ThemeIcon('warning', new vscode.ThemeColor('editorWarning.foreground'));
            case 'Medium':
                return new vscode.ThemeIcon('info', new vscode.ThemeColor('editorInfo.foreground'));
            case 'Low':
            default:
                return new vscode.ThemeIcon('issues', new vscode.ThemeColor('descriptionForeground'));
        }
    }
}

class InfoItem extends vscode.TreeItem {
    constructor(
        label: string,
        fullContent: string,
        icon: string,
        description?: string
    ) {
        super(label, vscode.TreeItemCollapsibleState.None);
        this.description = description || fullContent.split('\n')[0];
        
        // --- THIS IS THE FIX ---
        // We now pass the raw content to MarkdownString without the ``` code block wrapper.
        // This allows VS Code's renderer to wrap the text naturally.
        this.tooltip = new vscode.MarkdownString(fullContent, true);
        this.tooltip.isTrusted = true; // Allows for more advanced markdown if needed in the future

        this.iconPath = new vscode.ThemeIcon(icon);
    }
}

class LinkItem extends vscode.TreeItem {
    constructor(label: string, cweId: string) {
        super(label, vscode.TreeItemCollapsibleState.None);
        const cweNumber = cweId.replace('CWE-', '');
        this.description = cweId;
        this.iconPath = new vscode.ThemeIcon('link-external');
        this.tooltip = `Click to open ${cweId} details in your browser.`;
        this.command = {
            command: 'vscode.env.openExternal',
            title: 'Open CWE Link',
            arguments: [vscode.Uri.parse(`https://cwe.mitre.org/data/definitions/${cweNumber}.html`)]
        };
    }
}